// YouTube Transcript Reader Component
// Fetches and processes YouTube video transcripts using the official YouTube Data API v3

class YouTubeTranscriptReader {
    constructor() {
        this.name = 'YouTubeTranscriptReader';
        this.apiKey = null;
        this.serpApiKey = null;
        this.currentTranscript = null;
        this.currentMetadata = null;
    }

    /**
     * Set the YouTube API key
     * @param {string} key - YouTube Data API v3 key
     */
    setApiKey(key) {
        this.apiKey = key;
    }

    /**
     * Set the SerpApi key
     * @param {string} key - SerpApi key
     */
    setSerpApiKey(key) {
        this.serpApiKey = key;
    }

    /**
     * Extract video ID from various YouTube URL formats
     * @param {string} url - YouTube video URL
     * @returns {string|null} - Video ID or null if invalid
     */
    extractVideoId(url) {
        if (!url) return null;

        // Remove whitespace
        url = url.trim();

        // Direct video ID (11 characters)
        if (/^[a-zA-Z0-9_-]{11}$/.test(url)) {
            return url;
        }

        // Standard URL: https://www.youtube.com/watch?v=VIDEO_ID
        let match = url.match(/[?&]v=([^&]+)/);
        if (match) return match[1];

        // Short URL: https://youtu.be/VIDEO_ID
        match = url.match(/youtu\.be\/([^?]+)/);
        if (match) return match[1];

        // Embed URL: https://www.youtube.com/embed/VIDEO_ID
        match = url.match(/youtube\.com\/embed\/([^?]+)/);
        if (match) return match[1];

        // Mobile URL: https://m.youtube.com/watch?v=VIDEO_ID
        match = url.match(/m\.youtube\.com\/watch\?v=([^&]+)/);
        if (match) return match[1];

        return null;
    }

    /**
     * Fetch video metadata (title, description, channel, etc.)
     * @param {string} videoId - YouTube video ID
     * @returns {object} - Video metadata
     */
    async fetchVideoMetadata(videoId) {
        if (!this.apiKey) {
            throw new Error('YouTube API key not configured. Please add it to config.js');
        }

        const url = `https://www.googleapis.com/youtube/v3/videos?` +
            `part=snippet,contentDetails,statistics&` +
            `id=${videoId}&` +
            `key=${this.apiKey}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.error) {
                throw new Error(data.error.message || 'Failed to fetch video metadata');
            }

            if (!data.items || data.items.length === 0) {
                throw new Error('Video not found. Please check the URL and try again.');
            }

            const video = data.items[0];
            const snippet = video.snippet;
            const contentDetails = video.contentDetails;
            const statistics = video.statistics;

            return {
                videoId: videoId,
                title: snippet.title,
                description: snippet.description,
                channelTitle: snippet.channelTitle,
                publishedAt: snippet.publishedAt,
                thumbnails: snippet.thumbnails,
                duration: contentDetails.duration,
                viewCount: statistics.viewCount,
                likeCount: statistics.likeCount,
                tags: snippet.tags || [],
                defaultLanguage: snippet.defaultLanguage || snippet.defaultAudioLanguage || 'en'
            };
        } catch (error) {
            console.error('Error fetching video metadata:', error);
            throw error;
        }
    }

    /**
     * Get available caption tracks for a video
     * @param {string} videoId - YouTube video ID
     * @returns {array} - Array of available caption tracks
     */
    async getAvailableCaptions(videoId) {
        if (!this.apiKey) {
            throw new Error('YouTube API key not configured');
        }

        const url = `https://www.googleapis.com/youtube/v3/captions?` +
            `part=snippet&` +
            `videoId=${videoId}&` +
            `key=${this.apiKey}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.error) {
                throw new Error(data.error.message || 'Failed to fetch captions list');
            }

            if (!data.items || data.items.length === 0) {
                return [];
            }

            return data.items.map(item => ({
                id: item.id,
                language: item.snippet.language,
                name: item.snippet.name,
                trackKind: item.snippet.trackKind, // 'standard' or 'ASR' (auto-generated)
                isAutoGenerated: item.snippet.trackKind === 'ASR'
            }));
        } catch (error) {
            console.error('Error fetching captions list:', error);
            return [];
        }
    }

    /**
     * Download caption track
     * @param {string} captionId - Caption track ID
     * @returns {string} - Caption content in SRT format
     */
    async downloadCaption(captionId) {
        if (!this.apiKey) {
            throw new Error('YouTube API key not configured');
        }

        // Note: The YouTube Data API v3 requires OAuth for downloading captions
        // This is a limitation we need to handle
        throw new Error('Caption download requires OAuth authentication. Using alternative method...');
    }

    /**
     * Parse YouTube's automatic caption XML/JSON format
     * @param {string} captionData - Raw caption data
     * @returns {array} - Parsed transcript segments
     */
    parseCaptionData(captionData) {
        const segments = [];

        try {
            // Try parsing as JSON first (newer format)
            if (captionData.trim().startsWith('{')) {
                const data = JSON.parse(captionData);
                // Handle JSON format
                if (data.events) {
                    data.events.forEach(event => {
                        if (event.segs) {
                            event.segs.forEach(seg => {
                                if (seg.utf8) {
                                    segments.push({
                                        start: event.tStartMs / 1000,
                                        duration: event.dDurationMs / 1000,
                                        text: seg.utf8
                                    });
                                }
                            });
                        }
                    });
                }
            } else if (captionData.includes('<?xml')) {
                // Parse XML format
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(captionData, 'text/xml');
                const textNodes = xmlDoc.getElementsByTagName('text');

                for (let i = 0; i < textNodes.length; i++) {
                    const node = textNodes[i];
                    segments.push({
                        start: parseFloat(node.getAttribute('start') || 0),
                        duration: parseFloat(node.getAttribute('dur') || 0),
                        text: node.textContent
                    });
                }
            }
        } catch (error) {
            console.error('Error parsing caption data:', error);
        }

        return segments;
    }

    /**
     * Fetch transcript using browser fetch (more reliable in Electron renderer)
     * @param {string} videoId - YouTube video ID
     * @param {string} language - Language code (default: 'en')
     * @returns {object} - Transcript data
     */
    async fetchTranscriptPublic(videoId, language = 'en') {
        try {
            console.log('üé¨ [RENDERER] Fetching transcript for video:', videoId);
            
            // FIRST: Try SerpApi if API key is available (most reliable method!)
            if (this.serpApiKey) {
                console.log('‚ú® [RENDERER] Using SerpApi (recommended method)...');
                try {
                    const serpApiUrl = `https://serpapi.com/search.json?engine=youtube_video_transcript&v=${videoId}&language_code=${language}&api_key=${this.serpApiKey}`;
                    
                    const serpResponse = await fetch(serpApiUrl);
                    const serpData = await serpResponse.json();
                    
                    console.log('üìä [RENDERER] SerpApi response status:', serpResponse.status);
                    console.log('üìä [RENDERER] SerpApi FULL response:', JSON.stringify(serpData, null, 2));
                    console.log('üìä [RENDERER] SerpApi response keys:', Object.keys(serpData));
                    
                    if (serpData.transcript && serpData.transcript.length > 0) {
                        console.log('‚úÖ [RENDERER] SerpApi returned', serpData.transcript.length, 'segments!');
                        
                        const segments = serpData.transcript.map(item => ({
                            start: item.start_ms / 1000,
                            duration: (item.end_ms - item.start_ms) / 1000,
                            text: item.snippet
                        }));
                        
                        const fullText = segments.map(s => s.text).join(' ');
                        
                        return {
                            segments: segments,
                            fullText: fullText,
                            isAutoGenerated: serpData.search_parameters?.type === 'asr',
                            wordCount: fullText.split(/\s+/).filter(w => w.length > 0).length
                        };
                    } else {
                        console.warn('‚ö†Ô∏è [RENDERER] SerpApi returned no transcript data');
                        if (serpData.error) {
                            console.warn('‚ö†Ô∏è [RENDERER] SerpApi error message:', serpData.error);
                        }
                        
                        // Try fetching HTML from SerpApi and parsing it ourselves
                        if (serpData.search_metadata && serpData.search_metadata.raw_html_file) {
                            console.log('üîÑ [RENDERER] Trying SerpApi HTML file method...');
                            try {
                                const htmlResponse = await fetch(serpData.search_metadata.raw_html_file);
                                const html = await htmlResponse.text();
                                
                                if (html && html.length > 1000) {
                                    console.log('üìÑ [RENDERER] Got HTML from SerpApi, length:', html.length);
                                    
                                    // Check what keywords exist in the HTML
                                    const keywords = ['transcript', 'captions', 'timedtext', 'startMs', 'captionTracks', 'YTUBESCRIPT'];
                                    console.log('üîç [RENDERER] Checking HTML for transcript indicators:');
                                    for (const keyword of keywords) {
                                        const count = (html.match(new RegExp(keyword, 'gi')) || []).length;
                                        if (count > 0) {
                                            console.log(`  - "${keyword}": ${count} occurrences`);
                                        }
                                    }
                                    
                                    // Sample a portion of the HTML to see structure
                                    const sampleIndex = html.indexOf('transcript');
                                    if (sampleIndex > -1) {
                                        console.log('üìù [RENDERER] HTML sample around "transcript":', 
                                            html.substring(Math.max(0, sampleIndex - 200), sampleIndex + 500));
                                    }
                                    
                                    // Use the same HTML parsing patterns as the fallback method
                                    const transcriptPatterns = [
                                        /"startMs":"(\d+)"[^}]*?"snippet":\{"runs":\[\{"text":"([^"]*?)"\}\]/g,
                                        /"startMs":"(\d+)"[^}]{0,200}?"text":"([^"]*?)"/g,
                                        /"startMs":"(\d+)"[\s\S]{0,300}?"text":"([^"]+?)"/g
                                    ];
                                    
                                    for (let i = 0; i < transcriptPatterns.length; i++) {
                                        console.log(`üîç [RENDERER] Trying pattern ${i + 1} on SerpApi HTML...`);
                                        const matches = Array.from(html.matchAll(transcriptPatterns[i]));
                                        console.log(`  - Found ${matches.length} matches`);
                                        
                                        if (matches.length > 10) {
                                            console.log(`‚úÖ [RENDERER] Found ${matches.length} segments in SerpApi HTML!`);
                                            
                                            const segments = [];
                                            let fullText = '';
                                            
                                            for (const match of matches) {
                                                const start = parseInt(match[1]) / 1000;
                                                const text = match[2]
                                                    .replace(/\\n/g, ' ')
                                                    .replace(/\\"/g, '"')
                                                    .replace(/\\\\/g, '\\')
                                                    .replace(/\\u0026/g, '&')
                                                    .replace(/&#39;/g, "'")
                                                    .replace(/&quot;/g, '"')
                                                    .trim();
                                                
                                                if (text && text.length > 0) {
                                                    segments.push({ start, duration: 3, text });
                                                    fullText += text + ' ';
                                                }
                                            }
                                            
                                            if (segments.length > 10) {
                                                return {
                                                    segments: segments,
                                                    fullText: fullText.trim(),
                                                    isAutoGenerated: true,
                                                    wordCount: fullText.trim().split(/\s+/).filter(w => w.length > 0).length
                                                };
                                            }
                                        }
                                    }
                                }
                            } catch (htmlError) {
                                console.warn('‚ö†Ô∏è [RENDERER] Failed to parse SerpApi HTML:', htmlError.message);
                            }
                        }
                    }
                } catch (serpError) {
                    console.warn('‚ö†Ô∏è [RENDERER] SerpApi request failed:', serpError.message);
                    console.warn('‚ö†Ô∏è [RENDERER] Error details:', serpError);
                }
            } else {
                console.log('‚ÑπÔ∏è [RENDERER] No SerpApi key configured, trying direct method...');
            }
            
            // FALLBACK: Try direct method with better HTML parsing
            const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
            console.log('üé¨ [RENDERER] Fetching video page...');
            
            const response = await fetch(videoUrl, {
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
                }
            });
            
            const html = await response.text();
            
            console.log('Fetched video page, length:', html.length);
            
            // Try to extract ytInitialPlayerResponse which contains caption data
            let captionUrl = null;
            
            // Method 1: Extract from ytInitialPlayerResponse
            const playerResponseMatch = html.match(/var ytInitialPlayerResponse = ({.+?});/);
            if (playerResponseMatch) {
                try {
                    console.log('üì¶ [RENDERER] Found ytInitialPlayerResponse');
                    const playerResponse = JSON.parse(playerResponseMatch[1]);
                    
                    if (playerResponse.captions && playerResponse.captions.playerCaptionsTracklistRenderer) {
                        const captionTracks = playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks;
                        if (captionTracks && captionTracks.length > 0) {
                            // Find English caption or use first available
                            let track = captionTracks.find(t => t.languageCode === language) || captionTracks[0];
                            captionUrl = track.baseUrl;
                            console.log('‚úÖ [RENDERER] Found caption track via ytInitialPlayerResponse');
                        }
                    }
                } catch (e) {
                    console.warn('Failed to parse ytInitialPlayerResponse:', e.message);
                }
            }
            
            // Method 2: Extract from captionTracks JSON (fallback)
            if (!captionUrl) {
                const captionsMatch = html.match(/"captionTracks":\[([^\]]+)\]/);
                
                if (!captionsMatch) {
                    throw new Error('No captions found for this video');
                }
                
                // Extract the base URL for captions
                const baseUrlMatch = captionsMatch[1].match(/"baseUrl":"([^"]+)"/);
                
                if (!baseUrlMatch) {
                    throw new Error('Could not extract caption URL');
                }
                
                captionUrl = baseUrlMatch[1]
                    .replace(/\\u0026/g, '&')
                    .replace(/\\\//g, '/')
                    .replace(/\\/g, '');
            }
            
            if (!captionUrl) {
                throw new Error('Could not find caption URL');
            }
            
            console.log('Caption URL extracted:', captionUrl.substring(0, 100) + '...');
            
            // BEFORE trying the timedtext API, try to extract transcript from the HTML itself
            console.log('Attempting to extract transcript from HTML page...');
            
            // First, let's see what the transcript data actually looks like
            const transcriptKeywords = ['transcript', 'TimedText', 'captionTracks'];
            for (const keyword of transcriptKeywords) {
                const index = html.indexOf(keyword);
                if (index !== -1) {
                    const sample = html.substring(Math.max(0, index - 100), index + 400);
                    console.log(`Found "${keyword}" in HTML. Sample:`, sample);
                    // Only show first match to avoid log spam
                    break;
                }
            }
            
            // Look for transcript data with a much broader search
            const transcriptPatterns = [
                // Pattern 1: Full transcriptSegmentRenderer structure
                /"startMs":"(\d+)"[^}]*?"snippet":\{"runs":\[\{"text":"([^"]*?)"\}\]/g,
                // Pattern 2: Simpler startMs and text pattern
                /"startMs":"(\d+)"[^}]{0,200}?"text":"([^"]*?)"/g,
                // Pattern 3: Look for any startMs with nearby text
                /"startMs":"(\d+)"[\s\S]{0,300}?"text":"([^"]+?)"/g
            ];
            
            let foundTranscriptInHtml = false;
            const htmlSegments = [];
            let htmlFullText = '';
            
            for (let i = 0; i < transcriptPatterns.length; i++) {
                console.log(`Trying HTML pattern ${i + 1}...`);
                const matches = Array.from(html.matchAll(transcriptPatterns[i]));
                
                if (matches.length > 0) {
                    console.log(`‚úÖ Found ${matches.length} transcript segments in HTML with pattern ${i + 1}!`);
                    
                    for (const match of matches) {
                        const start = parseInt(match[1]) / 1000;
                        const text = match[2]
                            .replace(/\\n/g, ' ')
                            .replace(/\\"/g, '"')
                            .replace(/\\\\/g, '\\')
                            .replace(/\\u0026/g, '&')
                            .replace(/&#39;/g, "'")
                            .replace(/&quot;/g, '"')
                            .trim();
                        
                        if (text && text.length > 0) {
                            htmlSegments.push({ start, duration: 3, text });
                            htmlFullText += text + ' ';
                        }
                    }
                    
                    if (htmlSegments.length > 0) {
                        foundTranscriptInHtml = true;
                        break;
                    }
                }
            }
            
            if (foundTranscriptInHtml) {
                console.log('‚úÖ Successfully extracted transcript from HTML!');
                console.log('Total segments:', htmlSegments.length);
                console.log('Sample text:', htmlFullText.substring(0, 150));
                
                return {
                    segments: htmlSegments,
                    fullText: htmlFullText.trim(),
                    isAutoGenerated: true,
                    wordCount: htmlFullText.trim().split(/\s+/).filter(w => w.length > 0).length
                };
            }
            
            console.log('No transcript found in HTML, trying caption URL...');
            
            // Try JSON format first (less likely to be blocked)
            let captionUrlWithFormat = captionUrl;
            if (!captionUrl.includes('fmt=')) {
                captionUrlWithFormat = captionUrl + (captionUrl.includes('?') ? '&' : '?') + 'fmt=json3';
            }
            
            console.log('Trying JSON format first...');
            let captionResponse = await fetch(captionUrlWithFormat, {
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'application/json',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Referer': `https://www.youtube.com/watch?v=${videoId}`
                }
            });
            
            let jsonFormat = false;
            if (captionResponse.ok) {
                const contentType = captionResponse.headers.get('content-type');
                if (contentType && contentType.includes('json')) {
                    jsonFormat = true;
                    console.log('‚úÖ Got JSON format captions');
                }
            }
            
            // If JSON failed, try XML format
            if (!captionResponse.ok || !jsonFormat) {
                console.log('JSON format failed, trying XML format...');
                captionResponse = await fetch(captionUrl, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': '*/*',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Referer': `https://www.youtube.com/watch?v=${videoId}`
                    }
                });
            }
            
            if (!captionResponse.ok) {
                throw new Error(`Failed to fetch captions: HTTP ${captionResponse.status}`);
            }
            
            const responseText = await captionResponse.text();
            
            console.log('Received caption data, length:', responseText.length);
            
            if (!responseText || responseText.length === 0) {
                throw new Error('Received empty caption data. YouTube may be blocking caption downloads for this video.');
            }
            
            // Parse JSON if we got JSON format
            if (jsonFormat) {
                try {
                    const jsonData = JSON.parse(responseText);
                    const segments = [];
                    let fullText = '';
                    
                    if (jsonData.events) {
                        for (const event of jsonData.events) {
                            if (event.segs) {
                                const start = event.tStartMs / 1000;
                                const duration = event.dDurationMs / 1000;
                                const text = event.segs.map(s => s.utf8).join('').trim();
                                
                                if (text) {
                                    segments.push({ start, duration, text });
                                    fullText += text + ' ';
                                }
                            }
                        }
                    }
                    
                    if (segments.length > 0) {
                        console.log('‚úÖ Successfully parsed JSON captions, segments:', segments.length);
                        return {
                            segments: segments,
                            fullText: fullText.trim(),
                            isAutoGenerated: true,
                            wordCount: fullText.trim().split(/\s+/).filter(w => w.length > 0).length
                        };
                    }
                } catch (jsonError) {
                    console.warn('Failed to parse JSON captions:', jsonError.message);
                    // Fall through to XML parsing
                }
            }
            
            // Parse XML
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(responseText, 'text/xml');
            
            const textElements = xmlDoc.getElementsByTagName('text');
            
            console.log('Found', textElements.length, 'text elements in XML');
            
            if (textElements.length === 0) {
                throw new Error('No transcript segments found in captions');
            }
            
            const segments = [];
            let fullText = '';
            
            for (let i = 0; i < textElements.length; i++) {
                const element = textElements[i];
                const start = parseFloat(element.getAttribute('start') || '0');
                const duration = parseFloat(element.getAttribute('dur') || '3');
                const text = element.textContent
                    .replace(/\n/g, ' ')
                    .trim();
                
                if (text) {
                    segments.push({ start, duration, text });
                    fullText += text + ' ';
                }
            }
            
            console.log('Successfully parsed', segments.length, 'segments');
            
            return {
                segments: segments,
                fullText: fullText.trim(),
                isAutoGenerated: true,
                wordCount: fullText.trim().split(/\s+/).filter(w => w.length > 0).length
            };

        } catch (error) {
            console.error('Error fetching transcript in renderer:', error);
            
            // Fall back to IPC method
            console.log('Falling back to IPC method...');
            const { ipcRenderer } = require('electron');
            
            const url = `https://www.youtube.com/watch?v=${videoId}`;
            const result = await ipcRenderer.invoke('fetch-youtube-transcript', { url, language });
            
            if (!result.success) {
                throw new Error(result.error || 'Failed to fetch transcript');
            }
            
            return {
                segments: result.segments || [],
                fullText: result.fullText || '',
                isAutoGenerated: result.isAutoGenerated !== false,
                wordCount: result.wordCount || 0
            };
        }
    }

    /**
     * Process timedtext API response
     * @param {object} data - Response data
     * @param {boolean} isAutoGenerated - Whether captions are auto-generated
     * @returns {object} - Processed transcript
     */
    processTimedTextResponse(data, isAutoGenerated) {
        if (!data || !data.events) {
            throw new Error('Invalid transcript data - the video may not have captions');
        }

        const segments = [];
        let fullText = '';

        data.events.forEach(event => {
            if (event.segs) {
                const segmentText = event.segs
                    .map(seg => seg.utf8 || '')
                    .join('')
                    .replace(/\n/g, ' ')
                    .trim();

                if (segmentText) {
                    segments.push({
                        start: event.tStartMs / 1000,
                        duration: event.dDurationMs / 1000,
                        text: segmentText
                    });
                    fullText += segmentText + ' ';
                }
            }
        });

        if (segments.length === 0) {
            throw new Error('No transcript segments found - the video may not have captions');
        }

        return {
            segments: segments,
            fullText: fullText.trim(),
            isAutoGenerated: isAutoGenerated,
            wordCount: fullText.trim().split(/\s+/).filter(w => w.length > 0).length
        };
    }

    /**
     * Main method to fetch YouTube transcript
     * @param {string} url - YouTube video URL
     * @param {string} language - Preferred language code (default: 'en')
     * @returns {object} - Complete transcript data with metadata
     */
    async fetchTranscript(url, language = 'en') {
        try {
            console.log('üé¨ [RENDERER] Starting YouTube transcript fetch for URL:', url);
            
            // Extract video ID
            const videoId = this.extractVideoId(url);
            if (!videoId) {
                throw new Error('Invalid YouTube URL. Please provide a valid YouTube video link.');
            }

            console.log('üé¨ [RENDERER] Video ID:', videoId);

            // Fetch video metadata
            console.log('üé¨ [RENDERER] Fetching video metadata...');
            const metadata = await this.fetchVideoMetadata(videoId);
            this.currentMetadata = metadata;
            console.log('üé¨ [RENDERER] Metadata fetched:', metadata.title);

            // Try to get available captions (requires API key but is optional)
            let availableCaptions = [];
            try {
                if (this.apiKey) {
                    availableCaptions = await this.getAvailableCaptions(videoId);
                }
            } catch (error) {
                console.warn('Could not fetch captions list:', error.message);
            }

            // Fetch transcript using public API
            const transcript = await this.fetchTranscriptPublic(videoId, language);
            this.currentTranscript = transcript;

            return {
                success: true,
                videoId: videoId,
                title: metadata.title,
                channel: metadata.channelTitle,
                description: metadata.description,
                publishedAt: metadata.publishedAt,
                duration: metadata.duration,
                viewCount: metadata.viewCount,
                thumbnailUrl: metadata.thumbnails.medium?.url || metadata.thumbnails.default?.url,
                text: transcript.fullText,
                segments: transcript.segments,
                isAutoGenerated: transcript.isAutoGenerated,
                wordCount: transcript.wordCount,
                availableLanguages: availableCaptions.map(c => ({
                    code: c.language,
                    name: c.name,
                    isAuto: c.isAutoGenerated
                })),
                sourceUrl: `https://www.youtube.com/watch?v=${videoId}`,
                metadata: {
                    type: 'youtube-transcript',
                    imported: new Date().toISOString(),
                    language: language
                }
            };

        } catch (error) {
            console.error('Error fetching YouTube transcript:', error);
            return {
                success: false,
                error: error.message || 'Failed to fetch YouTube transcript'
            };
        }
    }

    /**
     * Format transcript with timestamps for display
     * @param {array} segments - Transcript segments
     * @param {boolean} includeTimestamps - Whether to include timestamps
     * @returns {string} - Formatted text
     */
    formatTranscript(segments, includeTimestamps = false) {
        if (!segments || segments.length === 0) return '';

        if (!includeTimestamps) {
            return segments.map(seg => seg.text).join(' ');
        }

        return segments.map(seg => {
            const timestamp = this.formatTimestamp(seg.start);
            return `[${timestamp}] ${seg.text}`;
        }).join('\n\n');
    }

    /**
     * Format seconds to MM:SS or HH:MM:SS
     * @param {number} seconds - Time in seconds
     * @returns {string} - Formatted timestamp
     */
    formatTimestamp(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Get current transcript data
     */
    getCurrentTranscript() {
        return this.currentTranscript;
    }

    /**
     * Get current video metadata
     */
    getCurrentMetadata() {
        return this.currentMetadata;
    }

    /**
     * Clear current transcript
     */
    clear() {
        this.currentTranscript = null;
        this.currentMetadata = null;
    }
}

// Create singleton instance and make it globally available
// Always create in browser context
window.youtubeTranscriptReader = new YouTubeTranscriptReader();
console.log('‚úÖ YouTube Transcript Reader initialized');

// Export for Node.js require() if needed
if (typeof module !== 'undefined' && module.exports) {
    module.exports = YouTubeTranscriptReader;
}
